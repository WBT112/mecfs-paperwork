/* global console */
import { readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const C_RESET = '\x1b[0m';
const C_GREEN = '\x1b[32m';
const C_DIM = '\x1b[2m';

const currentDir = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(currentDir, '../..');
const fundingPath = path.join(repoRoot, '.github', 'FUNDING.yml');
const outputPath = path.join(
  repoRoot,
  'app',
  'src',
  'lib',
  'funding.generated.ts',
);

const cleanValue = (value) => {
  const trimmed = value.trim();
  if (
    (trimmed.startsWith('"') && trimmed.endsWith('"')) ||
    (trimmed.startsWith("'") && trimmed.endsWith("'"))
  ) {
    return trimmed.slice(1, -1).trim();
  }
  return trimmed;
};

const parseInlineList = (value) => {
  const inner = value.replace(/^\[/, '').replace(/\]$/, '');
  if (inner.trim().length === 0) {
    return [];
  }
  return inner
    .split(',')
    .map((entry) => cleanValue(entry))
    .filter(Boolean);
};

const stripInlineComment = (value) => {
  const hashIndex = value.indexOf('#');
  if (hashIndex === -1) {
    return value;
  }
  return value.slice(0, hashIndex).trim();
};

const parseFunding = (content) => {
  const entries = {};
  let currentKey = null;

  for (const rawLine of content.split('\n')) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) {
      continue;
    }

    if (line.startsWith('- ')) {
      if (!currentKey) {
        continue;
      }
      const value = cleanValue(stripInlineComment(line.slice(2)));
      if (!value) {
        continue;
      }
      entries[currentKey] = entries[currentKey] ?? [];
      entries[currentKey].push(value);
      continue;
    }

    const match = line.match(/^([A-Za-z0-9_]+):\s*(.*)$/);
    if (!match) {
      continue;
    }

    const [, key, restRaw] = match;
    const rest = stripInlineComment(restRaw).trim();
    currentKey = key;
    if (!rest) {
      entries[key] = entries[key] ?? [];
      continue;
    }

    if (rest.startsWith('[') && rest.endsWith(']')) {
      entries[key] = parseInlineList(rest);
      currentKey = null;
      continue;
    }

    entries[key] = [cleanValue(rest)];
    currentKey = null;
  }

  return entries;
};

const resolveSponsorUrl = (entries) => {
  const customLinks = entries.custom ?? [];
  if (customLinks.length > 0) {
    return customLinks[0];
  }

  const githubSponsors = entries.github ?? [];
  if (githubSponsors.length > 0) {
    return `https://github.com/sponsors/${githubSponsors[0]}`;
  }

  const urlCandidates = [];
  for (const values of Object.values(entries)) {
    for (const value of values ?? []) {
      if (/^https?:\/\//i.test(value)) {
        urlCandidates.push(value);
      }
    }
  }

  return urlCandidates[0] ?? null;
};

console.log('ðŸ”„ Syncing sponsor funding URL...');
console.log(
  `${C_DIM}  - From: ${path.relative(repoRoot, fundingPath)}${C_RESET}`,
);
console.log(
  `${C_DIM}  - To:   ${path.relative(repoRoot, outputPath)}${C_RESET}`,
);

let sponsorUrl = null;
try {
  const fundingContent = await readFile(fundingPath, 'utf8');
  const fundingEntries = parseFunding(fundingContent);
  sponsorUrl = resolveSponsorUrl(fundingEntries);
} catch (error) {
  if (error?.code !== 'ENOENT') {
    throw error;
  }
  console.log(
    `${C_DIM}  - Funding file not found; sponsor link will be disabled.${C_RESET}`,
  );
}

const formatLiteral = (value) => {
  if (value === null) {
    return 'null';
  }
  const escaped = String(value).replace(/\\/g, '\\\\').replace(/'/g, "\\'");
  return `'${escaped}'`;
};

const outputContents =
  `// This file is generated by scripts/sync-funding.mjs. Do not edit.\n` +
  `export const FUNDING_URL: string | null = ${formatLiteral(sponsorUrl)};\n`;

await writeFile(outputPath, outputContents, 'utf8');

console.log(`${C_GREEN}âœ” Sponsor funding URL synced.${C_RESET}`);
