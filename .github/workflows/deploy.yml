name: Deploy to Docker Hub

on:
  push:
    branches:
      - main
      - staging
  pull_request:
    types: [closed]
    branches:
      - main
      - staging

permissions:
  contents: read

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    if: >-
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging')) ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'staging'))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha || github.sha }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Determine build configuration
        id: config
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            base_ref="${{ github.event.pull_request.base.ref }}"
          else
            base_ref="${GITHUB_REF#refs/heads/}"
          fi

          if [ "$base_ref" = "main" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "vite_mode=production" >> $GITHUB_OUTPUT
            echo "show_dev_formpacks=" >> $GITHUB_OUTPUT
            echo "deployment_env=production" >> $GITHUB_OUTPUT
            echo "tag_env=prod" >> $GITHUB_OUTPUT
          elif [ "$base_ref" = "staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "vite_mode=staging" >> $GITHUB_OUTPUT
            echo "show_dev_formpacks=true" >> $GITHUB_OUTPUT
            echo "deployment_env=staging" >> $GITHUB_OUTPUT
            echo "tag_env=staging" >> $GITHUB_OUTPUT
          else
            echo "Unknown branch"
            exit 1
          fi

      - name: Extract commit SHA (short)
        id: sha
        run: echo "short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            wbt112/mecfs-paperwork:${{ steps.config.outputs.tag_env }}
            wbt112/mecfs-paperwork:${{ steps.config.outputs.tag_env }}-${{ steps.sha.outputs.short }}
          build-args: |
            VITE_MODE=${{ steps.config.outputs.vite_mode }}
            VITE_SHOW_DEV_FORMPACKS=${{ steps.config.outputs.show_dev_formpacks }}
            VITE_DEPLOYMENT_ENV=${{ steps.config.outputs.deployment_env }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image digest
        run: echo "Image pushed successfully with tags ${{ steps.config.outputs.tag_env }} and ${{ steps.config.outputs.tag_env }}-${{ steps.sha.outputs.short }}"

  deploy:
    name: Deploy to Server
    needs: build-and-push
    runs-on: ubuntu-latest
    if: >-
      (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging')) ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'staging'))
    
    steps:
      - name: Checkout code (for compose file)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha || github.sha }}

      - name: Deploy to server via SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          SSH_HOST: ${{ secrets.DEPLOY_HOST }}
          SSH_USER: ${{ secrets.DEPLOY_USER }}
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          key_written=false
          if printf '%s' "$SSH_PRIVATE_KEY" | base64 -d 2>/dev/null | tr -d '\r' > ~/.ssh/deploy_key.tmp; then
            if grep -q -- "-----BEGIN" ~/.ssh/deploy_key.tmp; then
              mv ~/.ssh/deploy_key.tmp ~/.ssh/deploy_key
              key_written=true
            fi
          fi
          rm -f ~/.ssh/deploy_key.tmp
          if [ "$key_written" = false ]; then
            cat <<<"$SSH_PRIVATE_KEY" | tr -d '\r' > ~/.ssh/deploy_key
            if grep -q -- "-----BEGIN" ~/.ssh/deploy_key; then
              key_written=true
            else
              rm -f ~/.ssh/deploy_key
            fi
          fi
          if [ "$key_written" = false ]; then
            echo "::error::SSH_PRIVATE_KEY must be a PEM key or base64-encoded PEM."
            exit 1
          fi
          chmod 600 ~/.ssh/deploy_key
          if ! ssh-keygen -y -f ~/.ssh/deploy_key >/dev/null 2>&1; then
            echo "::error::SSH_PRIVATE_KEY is invalid or corrupted."
            exit 1
          fi
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts
          
          # Copy deployment files to server
          scp -i ~/.ssh/deploy_key compose.deploy.yaml Caddyfile "$SSH_USER@$SSH_HOST:/opt/mecfs-paperwork/"
          
          # Execute deployment commands on server
          ssh -i ~/.ssh/deploy_key "$SSH_USER@$SSH_HOST" \
            "cd /opt/mecfs-paperwork && \
             echo '$DOCKERHUB_TOKEN' | docker login -u '$DOCKERHUB_USERNAME' --password-stdin && \
             docker compose -f compose.deploy.yaml pull && \
             docker compose -f compose.deploy.yaml up -d && \
             docker image prune -af --filter 'until=168h'"
